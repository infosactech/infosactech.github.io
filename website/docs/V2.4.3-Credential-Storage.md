---
title: V2.4.3 Credential Storage
---



## Requirement:

Verify that if PBKDF2 is used, the iteration count SHOULD be as large as verification server performance will allow, typically at least 100,000 iterations. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering))

## Explanation:

Программное обеспечение генерирует хэш для пароля, но использует схему, которая не обеспечивает достаточный уровень вычислительных усилий, которые сделали бы атаки по взлому паролей неосуществимыми или дорогостоящими.

Многие механизмы хранения паролей вычисляют хэш и сохраняют хэш вместо сохранения исходного пароля в открытом виде. В этом дизайне аутентификация включает в себя принятие входящего пароля, вычисление его хэша и сравнение его с сохраненным хэшем.

Многие алгоритмы хэширования предназначены для быстрого выполнения с минимальными затратами, даже криптографические хэши. Однако такая эффективность является проблемой для хранения паролей, поскольку может снизить нагрузку на злоумышленника при взломе паролей методом грубой силы. Если злоумышленник может получить хэши каким-либо другим способом (например, путем внедрения SQL в базу данных, в которой хранятся хэши), то злоумышленник может хранить хэши в автономном режиме и использовать различные методы для взлома паролей путем эффективного вычисления хэшей. Без встроенной рабочей нагрузки современные атаки могут вычислять большое количество хэшей или даже исчерпать все пространство всех возможных паролей за очень короткий промежуток времени с использованием массивно-параллельных вычислений (таких как облачные вычисления) и GPU, ASIC или оборудование FPGA. В таком сценарии злоумышленнику помогает эффективный алгоритм хеширования.

Есть несколько свойств хеш-схемы, которые влияют на ее устойчивость к оффлайновым массовым параллельным атакам:

- Количество процессорного времени, необходимого для вычисления хеша («растяжение»)
- Объем памяти, необходимый для вычисления хэша (операции с "жестким использованием памяти").
- Включение случайного значения вместе с паролем в качестве входных данных для вычисления хэша (использовать так называемую «соль»)
- Хэш устроен так, что нет известного способа определить ввод (например, пароль), который создает это значение хеш-функции, кроме как путем угадывания возможных вводов («одностороннее» хеширование).
- Относительно количества всех возможных хэшей, которые могут быть сгенерированы, существует низкая вероятность создания одного и того же хэша для нескольких разных входных данных («коллизии»).


Обратите внимание, что требования безопасности для программного обеспечения могут различаться в зависимости от среды и значения паролей. Различные схемы могут не обеспечивать всех этих свойств, но все же обеспечивать достаточную безопасность для среды. И наоборот, решение может быть очень сильным в сохранении одного свойства, которое все еще очень слабо для атаки на другое свойство, или может не иметь возможности значительно снизить эффективность массивно-параллельной атаки.



## Remediation:

Чтобы убедиться, что PBKDF2 используется с достаточным количеством итераций, можно выполнить следующие шаги:

1. **Доступ к конфигурации сервера:** 

Потребуется доступ к параметрам конфигурации сервера, чтобы проверить количество итераций PBKDF2. В зависимости от настройки, это может быть сохранено в файле или доступно через административный интерфейс.

2. **Конфигурация PBKDF2:** 

Найти раздел конфигурации, относящийся к реализации PBKDF2. В этом разделе должен быть указан используемый алгоритм, а также количество итераций и другие параметры.

3. **Количество итераций:**

Убедиться, что количество итераций, указанное в конфигурации, составляет не менее 100 000. Если он ниже, нужно будет увеличить его, чтобы гарантировать безопасность сгенерированных хэшей паролей.

4. **Производительность сервера:**

После увеличения количества итераций нужно убедиться, что производительность сервера не пострадала. Это может включать тестирование времени отклика сервера и времени загрузки с различными сценариями загрузки.

5. **Обновление конфигурации:**

Если количество итераций увеличилось, а производительность сервера остается приемлемой, новое количество итераций следует сохранить в файле конфигурации, чтобы оно сохранялось после перезапуска сервера. 


Важно использовать достаточно большое количество итераций в PBKDF2, чтобы обеспечить безопасное хеширование паролей. Количество итераций действует как «фактор работы», который делает взлом хэшей паролей более затратным в вычислительном отношении.

Пример кода с количеством итераций равным 260000.


```python title:"Пример кода с количеством итераций равным 260000"
import base64
import hashlib
import secrets
ALGORITHM = "pbkdf2_sha256"
def hash_password(password, salt=None, iterations=260000):
if salt is None:
salt = secrets.token_hex(32)
assert salt and isinstance(salt, str) and "$" not in salt
assert isinstance(password, str)
pw_hash = hashlib.pbkdf2_hmac(
"sha256", password.encode("utf-8"), salt.encode("utf-8"), iterations
)
b64_hash = base64.b64encode(pw_hash).decode("ascii").strip()
return "{}${}${}${}".format(ALGORITHM, iterations, salt, b64_hash)
def verify_password(password, password_hash):
if (password_hash or "").count("$") != 3:
return False
algorithm, iterations, salt, b64_hash = password_hash.split("$", 3)
iterations = int(iterations)
assert algorithm == ALGORITHM
compare_hash = hash_password(password, salt, iterations)
return secrets.compare_digest(password_hash, compare_hash)

```


## Additional:

[https://til.simonwillison.net/python/password-hashing-with-pbkdf2](https://til.simonwillison.net/python/password-hashing-with-pbkdf2)

[https://cwe.mitre.org/data/definitions/916.html](https://cwe.mitre.org/data/definitions/916.html)




