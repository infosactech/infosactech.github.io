---
title: V1.5.2 Input and Output Architecture
---



## Requirement:

Verify that serialization is not used when communicating with untrusted clients. If this is not possible, ensure that adequate integrity controls (and possibly encryption if sensitive data is sent) are enforced to prevent deserialization attacks including object injection.

## Explanation:

Требование направлено на обеспечение безопасной работы приложения с сериализацией данных при взаимодействии с недоверенными клиентами. Требование рекомендует избегать сериализации при взаимодействии с недоверенными клиентами. Если сериализация необходима, то она должна выполняться с использованием средств контроля целостности, а также возможного шифрования для предотвращения атак на десериализацию, в том числе object injection. 

**Serialization and Deserialization**:

  - Serialization (Сериализация) - это процесс преобразования сложных структур данных (например, объектов) в формат, который можно легко передавать или хранить, а затем восстанавливать их в исходную форму (например, преобразование объектов в JSON или XML).
  - Deserialization (Десериализация) - это обратный процесс восстановления объектов данных из сериализованного формата.
 
**Communicating with Untrusted Clients**:

  - Недоверенные клиенты - это внешние объекты, взаимодействующие с вашим приложением, такие как пользователи, другие системы или компоненты сторонних производителей. 
  - Когда приложение взаимодействует с недоверенными клиентами, оно подвергается повышенному риску получения вредоносных данных, включая измененные или злонамеренно созданные данные.
 
**Avoid Serialization with Untrusted Clients**:

  - Требование не рекомендует использовать сериализацию при взаимодействии с недоверенными клиентами. Сериализация недоверенных данных может привести к уязвимостям десериализации, таким как атаки object injection.
 
**Object Injection Attacks**:

  - Object injection происходит, когда злоумышленник манипулирует сериализованными данными таким образом, что приложение инстанцирует и выполняет нежелательные объекты. Это может привести к проблемам безопасности, включая удаленное выполнение кода.
 
**Adequate Integrity Controls**:

  - Если сериализация с недоверенными клиентами необходима, то в требовании подчеркивается необходимость контроля целостности. Это подразумевает обеспечение того, что сериализованные данные не были подделаны в процессе передачи.
 
**Encryption for Sensitive Data**:

  - В случаях, когда речь идет о конфиденциальных данных, в дополнение к контролю целостности следует рассмотреть возможность шифрования. Шифрование обеспечивает конфиденциальность данных, гарантируя, что даже в случае перехвата они останутся конфиденциальными.


Предположим, у вас есть веб-приложение, которое получает данные в формате JSON от недоверенных клиентов и десериализует их для обработки. Чтобы выполнить это требование, можно реализовать следующее:


```python title="Пример кода"
import json
from cryptography.fernet import Fernet

# Function to deserialize and process JSON data from untrusted clients
def process_untrusted_json(serialized_data, encryption_key=None):
    try:
        if encryption_key:
            # Decrypt the serialized data using encryption
            f = Fernet(encryption_key)
            decrypted_data = f.decrypt(serialized_data.encode())
            data = json.loads(decrypted_data.decode())
        else:
            # Deserialize JSON data without encryption
            data = json.loads(serialized_data)
        
        # Implement further data processing here

        return data
    except (json.JSONDecodeError, ValueError) as e:
        # Handle deserialization errors
        raise Exception("Invalid data format")

# Example usage
if __name__ == '__main__':
    serialized_data = '{"username": "attacker", "role": "admin"}'
    encryption_key = b'YourSecretEncryptionKey'

    try:
        result = process_untrusted_json(serialized_data, encryption_key)
        print("Processed data:", result)
    except Exception as e:
        print("Error:", e)


```


В данном примере:

- JSON-данные, полученные от недоверенных клиентов, десериализуются с помощью функции **json.loads**.
- Опционально применяется шифрование с использованием **Fernet**, если указан ключ шифрования.


## Remediation:

Реализация требования, касающегося безопасной сериализации и десериализации данных при взаимодействии с недоверенными клиентами, предполагает применение методов и средств контроля для снижения рисков, связанных с уязвимостями десериализации. К ним относятся:

- **Avoid Unnecessary Serialization:** Проанализируйте кодовую базу приложения и сведите к минимуму использование сериализации и десериализации при взаимодействии с недоверенными клиентами. По возможности избегайте сериализации.
- **Validate and Sanitize Input:**Реализуйте проверку и очистку входных данных, чтобы гарантировать, что данные, получаемые от недоверенных клиентов, безопасны и соответствуют ожидаемым форматам.
- **Use Safe Serialization Formats:** Если сериализация необходима, используйте безопасные и хорошо определенные форматы сериализации, такие как JSON или XML, которые менее подвержены уязвимостям по сравнению с менее структурированными форматами, такими как Java-сериализация.
- **Implement Integrity Controls:** При сериализации данных рассчитывайте и включайте проверки целостности, такие как контрольные суммы или хэши. После десериализации следует проверить эти проверки на целостность, чтобы убедиться, что данные не были подделаны во время передачи.
- **Encryption for Sensitive Data:** Если ваше приложение работает с конфиденциальными данными, следует рассмотреть возможность шифрования сериализованных данных перед передачей и их расшифровки после десериализации. Используйте надежные алгоритмы шифрования и методы управления ключами.
- **Implement Content-Type Verification:** Перед десериализацией проверьте соответствие типа содержимого входящих данных ожидаемому типу. Убедитесь, что десериализация выполняется только в том случае, если тип содержимого является надежным и безопасным.
- **Implement Secure Deserialization Libraries:** По возможности используйте библиотеки десериализации, которые обеспечивают встроенную защиту от уязвимостей десериализации, например, возможность составления "whitelist " или "blacklist " списка классов при десериализации.
- **Enforce Access Controls:** Реализуйте контроль доступа, чтобы ограничить десериализацию конфиденциальных данных только авторизованными пользователями или компонентами.
- **Regularly Update Dependencies:** Поддерживайте библиотеки и фреймворки для сериализации и десериализации в актуальном состоянии. Уязвимости в этих библиотеках часто исправляются в новых версиях.
- **Security Testing:** Проводите тестирование на безопасность, включая тестирование на проникновение и анализ кода, для выявления и устранения уязвимостей десериализации.
- **Logging and Monitoring:** Внедрите логирование и мониторинг для обнаружения и реагирования на любые подозрительные или неожиданные действия по десериализации. Регистрируйте ошибки десериализации и события, связанные с безопасностью.


Приведем пример безопасной десериализации с использованием библиотеки json:


```python title="Пример кода"
import json

def secure_deserialization(serialized_data):
    try:
        # Deserialize JSON data
        deserialized_data = json.loads(serialized_data)
        return deserialized_data
    except json.JSONDecodeError as e:
        # Handle deserialization errors (e.g., invalid JSON)
        print("Deserialization Error:", e)
        return None

# Example usage
serialized_data = '{"name": "John Doe", "age": 30}'
deserialized_data = secure_deserialization(serialized_data)

if deserialized_data:
    print("Deserialized Data:", deserialized_data)
```


В данном примере используется функция **json.loads() **для безопасной десериализации JSON, которая включает в себя обработку ошибок для обработки некорректных JSON-данных.

## Additional:




