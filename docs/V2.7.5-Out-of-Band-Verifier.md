---
title: V2.7.5 Out of Band Verifier
---



## Requirement:

Verify that the out of band verifier retains only a hashed version of the authentication code.

## Explanation:

Проверка того, что внешний верификатор сохраняет только хешированную версию кода аутентификации, означает, что внешний верификатор не хранит фактический код аутентификации в виде открытого текста или в зашифрованной форме, которую можно легко расшифровать. Вместо этого внешний верификатор должен хранить хешированную версию кода аутентификации, которая представляет собой одностороннюю функцию, которая принимает открытый текст в качестве входных данных и создает выходные данные фиксированной длины (хэш). Цель сохранения только хешированной версии кода аутентификации состоит в том, чтобы гарантировать, что даже если база данных внешнего верификатора будет скомпрометирована, злоумышленник не сможет получить фактические коды аутентификации. Вместо этого они будут иметь доступ только к хешированным версиям, которые для них бесполезны, поскольку с вычислительной точки зрения невозможно обратить хеш-функцию.

## Remediation:



Чтобы внедрить исправление для проверки того, что внешний верификатор сохраняет только хешированную версию кода аутентификации, можно предпринять следующие шаги: 

- Выберите безопасную одностороннюю хеш-функцию: выберите безопасную одностороннюю хеш-функцию, например SHA-256, для хэширования кода аутентификации. 
- Создайте уникальную и случайную соль: создайте уникальную и случайную соль для каждого кода аутентификации. Соль должна иметь достаточную длину, чтобы злоумышленники не могли использовать предварительно вычисленные хеш-таблицы. 
- Объедините соль и код аутентификации: Объедините соль с кодом аутентификации перед ее хешированием. 
- Хэшируйте комбинированную соль и код аутентификации: хешируйте комбинированную соль и код аутентификации, используя выбранную одностороннюю хеш-функцию. 
- Сохраните хэш-код: сохраните хэш-код в базе данных внешнего верификатора. 
- Проверка подлинности кода: когда внешнему верификатору необходимо проверить подлинность кода, он хеширует код, предоставленный пользователем, объединяет его с соответствующей солью и сравнивает результат с хешированной версией, хранящейся в его база данных. Если два хэша совпадают, код считается подлинным. 


Выполняя эти шаги, внешний верификатор может гарантировать, что он сохраняет только хешированную версию кода аутентификации и что даже если его база данных скомпрометирована, злоумышленник не сможет получить фактические коды аутентификации.

Вот пример реализации шагов исправления в Python:


```python title="Пример реализации безопасного верификатора"
import hashlib
import os

def hash_authentication_code(code, salt):
    # Combine the salt and code
    combined = salt + code
    # Hash the combined value using SHA-256
    hashed = hashlib.sha256(combined.encode()).hexdigest()
    return hashed

def verify_authentication_code(code, hashed, salt):
    # Hash the provided code using the same method as before
    hashed_input = hash_authentication_code(code, salt)
    # Compare the hashed input with the stored hashed value
    if hashed_input == hashed:
        return True
    else:
        return False

# Generate a new salt for each authentication code
salt = os.urandom(16).hex()

# Hash the authentication code
hashed_code = hash_authentication_code("123456", salt)

# Verify the authenticity of a code
if verify_authentication_code("123456", hashed_code, salt):
    print("Code is authentic.")
else:
    print("Code is not authentic.")


```


В этом коде показано, как хэшировать код аутентификации с помощью уникальной соли и SHA-256, а также как проверять подлинность кода путем сравнения хешированного ввода с сохраненным хешированным значением.

## Additional:




