---
title: V2.7.3 Out of Band Verifier
---



## Requirement:

Verify that the out of band verifier authentication requests, codes, or tokens are only usable once, and only for the original authentication request.

## Explanation:

Проверка того, что запросы аутентификации, коды или токены, передаваемые по дополнительному каналу, можно использовать только один раз и только для исходного запроса аутентификации, является важной мерой безопасности для предотвращения несанкционированного доступа к конфиденциальной информации. Внеполосная аутентификация — это дополнительная мера безопасности, используемая для подтверждения личности пользователя. Процесс аутентификации включает в себя отправку кода или токена пользователю по отдельному каналу, такому как текстовое сообщение или электронная почта, и требование от пользователя ввести код или токен обратно в систему для подтверждения своей личности. Гарантируя, что коды или токены можно использовать только один раз и только для исходного запроса аутентификации, система может предотвратить использование злоумышленником украденного или перехваченного кода или токена для получения доступа к конфиденциальной информации. Это помогает поддерживать безопасность системы и снижает риск несанкционированного доступа. Чтобы убедиться, что запросы, коды или токены проверки подлинности внешнего верификатора можно использовать только один раз и только для исходного запроса проверки подлинности, вы можете отслеживать использование кодов или токенов, проверять любые попытки повторного использования кода или токена, проверить, правильно ли система помечает коды или токены как использованные после их ввода, и протестировать систему, преднамеренно пытаясь повторно использовать код или токен.


## Remediation:



Вот несколько шагов, которые помогут решить проблему, если запросы, коды или токены проверки подлинности внешнего верификатора не ограничены должным образом однократным использованием:

1. **Определить основную причину.**

Определить, почему запросы, коды или токены проверки подлинности внешнего верификатора не ограничиваются должным образом однократным использованием. Это может быть связано с ошибкой в ​​коде, неправильной конфигурацией или отсутствием надлежащей проверки в системе.

2. **Устранение проблемы.**

После определения основной причины примите меры для устранения проблемы. Это может включать обновление кода для правильного отслеживания и ограничения использования кодов или токенов, перенастройку системы или добавление дополнительных проверок, чтобы гарантировать, что коды или токены используются только один раз.

3. **Проверить исправление.**

После внесения любых изменений протестировать систему, чтобы убедиться, что запросы, коды или токены проверки подлинности внешнего верификатора теперь должным образом ограничены однократным использованием.

4. **Задокументировать изменения.**

Задокументировать внесенные изменения и шаги, предпринятые для устранения проблемы. Эта информация может быть полезна для дальнейшего использования и для предотвращения возникновения подобных проблем в будущем. 


Конкретная реализация шагов исправления зависит от используемой технологии и языка программирования, но вот пример реализации на Python:


```python title:Пример реализации проверки одноразового кода
# function to generate a one-time token
def generate_token():
    # generate a random token with 32 characters
    return ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(32))

# dictionary to store the mapping between authentication request and token
auth_requests = {}

# function to handle the authentication request
def handle_auth_request(user_id):
    # generate a new token for the authentication request
    token = generate_token()
    # store the mapping between the authentication request and the token
    auth_requests[token] = user_id
    # send the token to the user
    send_token_to_user(user_id, token)

# function to handle the token validation
def handle_token_validation(token):
    # check if the token is present in the auth_requests dictionary
    if token in auth_requests:
        # retrieve the user_id for the token
        user_id = auth_requests[token]
        # remove the token from the auth_requests dictionary
        del auth_requests[token]
        # return the user_id
        return user_id
    else:
        # return None if the token is not present in the auth_requests dictionary
        return None


```


В этом примере новый токен создается для каждого запроса аутентификации и сохраняется в словаре auth_requests. Токен отправляется пользователю, который затем вводит его обратно в систему для подтверждения своей личности. Функция handle_token_validation проверяет, присутствует ли токен в словаре auth_requests, и, если это так, извлекает user_id и удаляет токен из словаря. Это гарантирует, что каждый токен можно использовать только один раз и только для исходного запроса аутентификации.

## Additional:




