---
title: V12.3.4 File Execution
---



## Requirement:

Verify that the application protects against Reflective File Download (RFD) by validating or ignoring user-submitted filenames in a JSON, JSONP, or URL parameter, the response Content-Type header should be set to text/plain, and the Content-Disposition header should have a fixed filename.

## Explanation:

Требование защищает от атак типа Reflective File Download (RFD), обеспечивая правильную проверку или игнорирование имен файлов, передаваемых пользователем, при использовании их в параметрах JSON, JSONP или URL. Кроме того, в заголовке Content-Type ответа должно быть установлено значение text/plain, а в заголовке Content-Disposition должно быть указано фиксированное имя файла. Таким образом, злоумышленники не смогут обманом заставить пользователя загрузить вредоносное содержимое, манипулируя именами файлов.

1 
**Reflective File Download (RFD):**

  - RFD - это атака, в ходе которой злоумышленники манипулируют пользовательским вводом, чтобы обманом заставить жертву загрузить вредоносные файлы из доверенного домена. Злоумышленники создают URL-адреса, которые при нажатии на них инициируют загрузку файла с вредоносным содержимым.
1 
**User-Submitted Filenames:**

  - Под этим понимаются названия файлов, предоставляемые пользователями в полях ввода, JSON, JSONP или параметрах URL. Эти имена файлов могут использоваться в ссылках на загрузку, рендеринге контента и других взаимодействиях.
1 
**JSON and JSONP Parameters:**

  - Злоумышленники могут внедрять вредоносные имена файлов в параметры JSON или JSONP, заставляя жертв неосознанно загружать вредоносный контент.
1 
**URL Parameters:**

  - URL-адреса с измененными параметрами могут приводить жертв к загрузке файлов с вредоносным содержимым.


## Remediation:

Для выполнения этого требования и предотвращения RFD-атак:

1 
**Validate and Sanitize Filenames:**

  - Для предотвращения внедрения вредоносных имен файлов тщательно проверяйте и обрабатывайте имена файлов, отправляемых пользователями.
1 
**Set Content-Type Header:**

  -  Убедитесь, что заголовок Content-Type ответа всегда имеет значение text/plain. Это не позволит браузерам интерпретировать ответ как исполняемое содержимое.
1 
**Set Content-Disposition Header:**

  - Установите фиксированное имя файла с помощью заголовка Content-Disposition при обслуживании файлов. Не забудьте убрать специальные символы в имени файла.
1 
**Escaping Characters:**

  - При обслуживании файлов задавайте фиксированное имя файла с помощью заголовка Content-Disposition. Это позволяет избежать двусмысленности и манипуляций с именем файла.
1 
**Implement URL Parameter Validation:**

  - При выводе имен файлов в заголовках ответа экранируйте специальные символы для предотвращения инъекций.
1 
**Implement JSON and JSONP Protection:**

  - Для предотвращения инъекционных атак используйте строгую проверку входных данных и кодирование выходных данных при работе с параметрами JSON и JSONP.


 Важно защищаться от RFD-атак, проверяя или игнорируя имена файлов, отправленные пользователем, устанавливая заголовок Content-Type ответа на text/plain и устанавливая заголовок Content-Disposition с фиксированным именем файла. Это помогает предотвратить использование злоумышленниками уязвимостей в приложении, чтобы обманом заставить пользователей загружать вредоносные файлы или выполнять сценарии. Проверяя или игнорируя имена файлов, устанавливая заголовок Content-Type и устанавливая заголовок Content-Disposition, вы можете гарантировать, что приложение не разрешает несанкционированный доступ к непредусмотренным файлам или ресурсам и что ответ не выполняется как сценарий. 

Пример того, как вы можете реализовать эту проверку в веб-приложении:


```
from flask import Flask, Response, request, abort

app = Flask(__name__)

ALLOWED_FILES = ["file1.txt", "file2.txt"]  # Example list of allowed files

@app.route("/download")
def download_file():
    # Get the filename parameter from the query string
    filename = request.args.get("filename")

    # Validate and sanitize the filename
    if filename not in ALLOWED_FILES:
        return "Invalid filename", 400

    # Set the response headers
    response = Response("File content here", content_type="text/plain")
    response.headers["Content-Disposition"] = f'attachment; filename="{filename}"'
    return response

if __name__ == "__main__":
    app.run()
  
```


Для проверки соблюдения этого требования:

- Проверьте код на предмет того, что имена файлов, передаваемые пользователем, проверяются и очищаются должным образом во всех соответствующих контекстах.
- Проверьте заголовки ответов, чтобы убедиться, что для заголовка Content-Type установлено значение text/plain для ответов на загрузку файлов.
- Проверьте заголовки ответов, чтобы убедиться, что в заголовке Content-Disposition указано фиксированное имя файла и что специальные символы экранированы.
- Проведите тестирование безопасности, попытавшись манипулировать именами файлов и инициировать вредоносные загрузки. Убедитесь, что приложение не принимает недопустимые имена файлов и передает файлы с правильными заголовками.




## Additional:

[https://cwe.mitre.org/data/definitions/641.html](https://cwe.mitre.org/data/definitions/641.html)




