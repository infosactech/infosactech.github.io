---
title: V4.1.1 General Access Control Design
---



## Requirement:

Verify that the application enforces access control rules on a trusted service layer, especially if client-side access control is present and could be bypassed.

## Explanation:

Когда сервер полагается на механизмы защиты, расположенные на стороне клиента, злоумышленник может изменить поведение на стороне клиента, чтобы обойти механизмы защиты, что может привести к неожиданному взаимодействию между клиентом и сервером. Последствия будут разными, в зависимости от того, что механизмы пытаются защитить.

## Remediation:

Чтобы проверить применение правил управления доступом в приложении, вы можете выполнить следующие действия: 

- Просмотрите код и архитектуру приложения, чтобы определить уровень доверенных служб и применяемые им правила управления доступом. 
- Проверьте поведение приложения, попытавшись получить доступ к ограниченным ресурсам со стороны клиента без надлежащей проверки подлинности и авторизации. 
- Убедитесь, что уровень доверенных служб запрещает доступ к этим ресурсам и возвращает соответствующее сообщение об ошибке или код состояния. 
- Повторите тест для разных ролей пользователей и разрешений, чтобы убедиться, что правила управления доступом последовательно применяются для всех пользователей. 
- Рассмотрите возможность ведения журнала и мониторинга событий управления доступом для обнаружения любых нарушений или обходов правил управления доступом в будущем. 


Выполняя эти шаги, вы можете гарантировать, что правила управления доступом приложения применяются на уровне доверенных служб, и что управление доступом на стороне клиента невозможно обойти.

Вот пример кода на Python, демонстрирующий принудительное управление доступом в веб-приложении Flask:


```python title="Демонстрация принудительного управления доступом в веб-приложении Flask"
from flask import Flask, request
from flask_jwt_extended import JWTManager, jwt_required, get_jwt_claims

app = Flask(__name__)
app.config['JWT_SECRET_KEY'] = 'secret_key'
jwt = JWTManager(app)

@app.route('/protected_resource')
@jwt_required
def protected_resource():
    claims = get_jwt_claims()
    user_role = claims['role']
    if user_role != 'admin':
        return "Access Denied", 403
    return "Access Granted", 200

if __name__ == '__main__':
    app.run()


```


В этом примере декоратор jwt_required из библиотеки flask_jwt_extended используется для принудительной аутентификации конечной точки **/protected_resource**. Функция **get_jwt_claims** используется для извлечения утверждений JWT, содержащих роль пользователя, из входящего запроса. Если роль пользователя не admin, доступ к ресурсу будет запрещен с кодом состояния 403 Forbidden. Это демонстрирует, как приложение может применять правила управления доступом на уровне доверенных служб.




## Additional:

[https://cwe.mitre.org/data/definitions/602.html](https://cwe.mitre.org/data/definitions/602.html)




